/**
 * @author Sascha Kretzschmann
 * @desc This module provides function for each test case.
 *   		 Additionally this module provide set up and
 *   		 tear down configurations to reuse.
 */
module Car2X_Functions {
	import from Car2X_Templates {
		template
			m_Filter_doorStatus_Start,
			m_Filter_doorStatus_Stop,
			m_Filter_headLampStatus_Start,
			m_Filter_headLampStatus_Stop,
			m_Filter_ignitionState_Start,
			m_Filter_ignitionState_Stop,
			m_Filter_steeringWheel_Start,
			m_Filter_steeringWheel_Stop,
			m_Filter_transmissionGear_Start,
			m_Filter_transmissionGear_Stop,
			mw_Filter_Response_dS,
			mw_Filter_Response_hL,
			mw_Filter_Response_iS,
			mw_Filter_Response_sW,
			mw_Filter_Response_tG,
			mw_Filter_Response_vS;
	}

	import from Car2X_Types {
		type DoorStatus, FilterResponse, IgnitionStatus, TransmissionGear;
	}

	import from Car2X_ConfigSystem {type TesterComponentType;}

	/**
	 * @desc function to measure speed for a defined period of time
	 * @param p_speed target speed (in km/h)
	 * @param p_holding_time time with target speed (in sec)
	 * @param p_variance variance range around the targetAngle (in km/h)
	 * @param p_interval time until timeout (in sec)
	 * @verdict
	 */
	function f_TP_VEHICLE_SPEED(float p_speed, float p_holding_time,
								float p_variance, float p_interval)
		runs on TesterComponentType  {
		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_VEHICLE_SPEED_SUB(p_speed, p_holding_time, p_variance,
								   p_interval);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Testbody function for
	 * @see Car2X_Testcases.TC_VEHICLE_SPEED_OVER_50
	 * @verdict pass The given speed ist greater than 50.0.
	 * @verdict fail Due to invalid parameter.
	 * @verdict inconc Due to a timeout.
	 */
	function f_TP_VEHICLE_SPEED_SUB(float p_speed, float p_holding_time,
									float p_variance, float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_speed;
		timer t_holding;
		var float speed;

		// start the timer
		t_TC.start(p_interval);
		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_vS) -> value v_speed {
				t_TC.stop;
				// check whether vehicle speed is greater than given speed
				speed := str2float(v_speed.valueA);
				if (max(p_speed - p_variance, 0.0) <= speed and
					speed >= min(p_speed + p_variance, 655.0)) {
					t_holding.start(p_holding_time);
					while (t_holding.running and v_ret == pass) {
						filterPort.receive(mw_Filter_Response_vS) ->
						value v_speed;
						if (str2float(v_speed.valueA) >= p_speed) {
							v_ret := pass;
						} else {
							v_ret := fail;
						}
					}
				} else {
					v_ret := fail;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc function to measure steering wheel angle; calls
	 *   f_TP_STEERING_WHEEL_SUB; range = -600 to 600
	 * @param targetAngle angle which should be reached (in degree)
	 * @param variance variance range around the targetAngle (in degree)
	 * @verdict
	 */
	function f_TP_STEERING_WHEEL_ANGLE(float targetAngle, float variance)
		runs on TesterComponentType  {
		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_STEERING_WHEEL_ANGLE_SUB(- 600.0, 50.0, 2.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc function request steering wheel angle from the canfilter
	 * @param targetAngle angle which should be reached
	 * @param variance variance range around the targetAngle
	 * @param p_interval time until timeout; should be greater then the
	 *   intervall time in m_Filter_doorStatus_Start
	 * @verdict
	 */
	function f_TP_STEERING_WHEEL_ANGLE_SUB(float targetAngle, float variance,
										   float interval)
		runs on TesterComponentType  {
		var template FilterResponse v_angle;

		// start steering Wheel request
		filterPort.send(m_Filter_steeringWheel_Start);

		t_TC.start(interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_sW) -> value v_angle {
				if (max(targetAngle - variance, - 600.0) <=
					str2float(v_angle.valueA) and
					str2float(v_angle.valueA) <=
					min(targetAngle + variance, 600.0)) {
					v_ret := pass;
					t_TC.stop;
				} else {
					v_ret := fail;
					t_TC.stop;
				}
			}
			[] filterPort.receive {
				v_ret := fail;
				t_TC.stop;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
		// stop steering wheel request
		filterPort.send(m_Filter_steeringWheel_Stop);
	}

	/**
	 * @desc function to measure headlamp status; calls f_TP_HEADLAMP_STATUS_SUB
	 * @param p_Status <b>true</b> headlamp on; <b>false</b> headlamp off
	 * @param p_timeout intervall until timeout (in sec)
	 * @verdict
	 */
	function f_TP_HEADLAMP_STATUS(boolean p_Status, float p_timeout)
		runs on TesterComponentType  {

		t_TC_Global.start(p_timeout);
		while (t_TC_Global.running) {
			f_TP_HEADLAMP_STATUS_SUB(p_Status, 0.8);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		// stage failed -> end whole TC
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc receive values from canfilter
	 * @param p_Status target status of headlamp; <b>true</b> headlamp on;
	 *   <b>false</b> headlamp off
	 * @param p_interval time until timeout
	 * @verdict
	 */
	function f_TP_HEADLAMP_STATUS_SUB(boolean p_Status, float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_headLampStatus;

		// start ignition status request
		filterPort.send(m_Filter_headLampStatus_Start);

		t_TC.start(p_interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_hL) ->
			   value v_headLampStatus {
				if (p_Status == str2bool(v_headLampStatus.valueA)) {
					v_ret := pass;
				} else {
					v_ret := fail;
				}
				t_TC.stop;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		// stop ignition status request
		filterPort.send(m_Filter_headLampStatus_Stop);
	}

	/**
	 * @desc measure the ignition status, calls f_TP_IGNITION_STATUS_SUB
	 * @param ignitionStatus enum value of type IgnitionStatus
	 * @verdict
	 */
	function f_TP_IGNITION_STATUS(IgnitionStatus ignitionStatus)
		runs on TesterComponentType  {

		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_IGNITION_STATUS_SUB(ignitionStatus, 0.5);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
	}

	/**
	 * @desc receive ignition status value from canfilter and compare with
	 *   target status
	 * @param ignitionStatus enum value of type IgnitionStatus
	 * @param interval time until timeout; should be greater then inteval in
	 *   m_Filter_ignitionState_Start
	 * @verdict
	 */
	function f_TP_IGNITION_STATUS_SUB(IgnitionStatus ignitionStatus,
									  float interval)
		runs on TesterComponentType  {

		var template FilterResponse v_ignitionStatus;

		// start ignition status request
		filterPort.send(m_Filter_ignitionState_Start);

		t_TC.start(interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_iS) ->
			   value v_ignitionStatus {
				if (ignitionStatus2str(ignitionStatus) ==
					v_ignitionStatus.valueA) {
					v_ret := pass;
				} else {
					v_ret := fail;
				}
				t_TC.stop;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		// stop ignition status request
		filterPort.send(m_Filter_ignitionState_Stop);
	}

	/**
	 * @desc measure transmission gear and campore with target state
	 * @param gear target state; enum value of type TransmissionGear
	 * @param p_interval time until timeout
	 * @verdict
	 */
	function f_TP_TRANSMISSION_GEAR_STATUS(TransmissionGear gear,
										   float p_interval)
		runs on TesterComponentType  {
		t_TC_Global.start(p_interval);

		while (t_TC_Global.running) {
			f_TP_TRANSMISSION_GEAR_STATUS_SUB(gear, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	/**
	 * @desc receive transmission gear from canfilter
	 * @param gear traget gear; enum value of type TransmissionGear
	 * @param p_interval time until timeout; should be geater then
	 *   m_Filter_transmissionGear_Start
	 * @verdict
	 */
	function f_TP_TRANSMISSION_GEAR_STATUS_SUB(TransmissionGear gear,
											   float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_gearStatus;

		filterPort.send(m_Filter_transmissionGear_Start);
		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_tG) -> value v_gearStatus {
				if (gearStatus2Str(gear) == v_gearStatus.valueA) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
		filterPort.send(m_Filter_transmissionGear_Stop);
	}

	/**
	 * @desc  Function to get door status from canfilter; calls
	 *   f_TP_DOORS_STATUS_SUB function
	 * @param p_door Enumeration value to define which door
	 * @param p_status    status of the door; <b>true</b> for open
	 *   door; <b>false</b> for close door
	 * @param p_interval defines time until timeout (in sec)
	 * @verdict
	 */
	function f_TP_DOOR_STATUS(DoorStatus p_door, boolean p_status,
							  float p_interval) runs on TesterComponentType  {

		t_TC_Global.start(p_interval);

		while (t_TC_Global.running) {
			f_TP_DOOR_STATUS_SUB(p_door, p_status, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	/**
	 * @desc function receive door status from canfilter
	 * @param p_door Enumeration value to define which door
	 * @param p_status          status of the door; <b>true</b> for open door;
	 *   <b>false</b> for close door
	 * @param p_interval time until timeout; should be greater then the
	 *   intervall time in m_Filter_doorStatus_Start
	 * @verdict
	 */
	function f_TP_DOOR_STATUS_SUB(DoorStatus p_door, boolean p_status,
								  float p_interval)
		runs on TesterComponentType  {

		var template FilterResponse v_doorStatus;

		filterPort.send(m_Filter_doorStatus_Start);

		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_dS) -> value v_doorStatus {
				if (doorStatus2Str(p_door) == v_doorStatus.valueA and
					p_status == v_doorStatus.valueB) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		filterPort.send(m_Filter_doorStatus_Stop);
	}

	/**
	 * @desc Set up the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 Maps the port of the tester to the system port.
	 */
	function f_setUp() runs on TesterComponentType  {


		// create an instance of the tester
		var TesterComponentType Tester;
		Tester := TesterComponentType.create;

		v_ret := pass;
		v_stage := 1;

		// map the tester port to the system port
		map(self:filterPort, system:filterPort);
	}

	/**
	 * @desc Auxiliary function to find max value of two float values
	 * @param valueA
	 * @param valueB
	 * @return
	 * @verdict
	 */
	function max(float valueA, float valueB) return float  {
		if (valueA > valueB) {
			return valueA;
		} else {
			return valueB;
		}
	}

	/**
	 * @desc Auxiliary function to find min value of two float values
	 * @param valueA
	 * @param valueB
	 * @return
	 * @verdict
	 */
	function min(float valueA, float valueB) return float  {
		if (valueA < valueB) {
			return valueA;
		} else {
			return valueB;
		}
	}

	/**
	 * @desc Auxiliary function to cast the ignitionStatus to charstring.
	 *   		 We cannot compare an enum type with a charstring that is
	 *   		 needed for the function
	 * @see f_ignitionStatus_SUB
	 * @param ignitionStatus
	 * @return charstring Ignition status as string
	 */
	function ignitionStatus2str(IgnitionStatus ignitionStatus)
		return charstring  {
		select (ignitionStatus) {
			case (e_off) {
				return "off";
			}
			case (e_accessory) {
				return "accessory";
			}
			case (e_run) {
				return "run";
			}
			case (e_start) {
				return "start";
			}
		}
	}

	/**
	 * @desc Auxiliary function to cast enum value of DoorStatus to string
	 * @param doorStatus
	 * @return
	 * @verdict
	 */
	function doorStatus2Str(DoorStatus doorStatus) return charstring  {
		select (doorStatus) {
			case (e_driver) {
				return "driver";
			}
			case (e_passenger) {
				return "passener";
			}
			case (e_rear_left) {
				return "rear_left";
			}
			case (e_rear_right) {
				return "rear_right";
			}
		}
	}

	/**
	 * @desc Auxiliary function to cast enum value of TransmissionGear to string
	 * @param gear
	 * @return
	 * @verdict
	 */
	function gearStatus2Str(TransmissionGear gear) return charstring  {
		select (gear) {
			case (e_first) {
				return "first";
			}
			case (e_second) {
				return "second";
			}
			case (e_third) {
				return "third";
			}
			case (e_fourth) {
				return "fourth";
			}
			case (e_fifth) {
				return "fifth";
			}
			case (e_sixth) {
				return "sixth";
			}
			case (e_seventh) {
				return "seventh";
			}
			case (e_eighth) {
				return "first";
			}
			case (e_ninth) {
				return "ninth";
			}
			case (e_tenth) {
				return "tenth";
			}
			case (e_reverse) {
				return "reverse";
			}
			case (e_neutral) {
				return "neutral";
			}
		}
	}

	/**
	 * @desc Function to set the verdict and communicate via the action statment
	 *   with TTman.
	 *   		 Furthermore, increment the stage for the test case.
	 * @param verdict Verdicttype for the given stage.
	 * @param stage Stage Current stage.
	 * @return integer The new stage.
	 */
	function f_set_verdict_and_stage(verdicttype verdict, integer stage) {
		setverdict(verdict);
		stage := stage + 1;
		// send stage information
		action("stage:" & int2str(stage));
	}

	/**
	 * @desc Tear down the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 UnMaps the ports.
	 */
	function f_tearDown() runs on TesterComponentType  {
		unmap(self:filterPort, system:filterPort);
		stop;
	}

	/**
	 * @desc Auxiliary function to cast a received strong to boolean
	 * @param p_str
	 * @return <b>true</b> if p_str == "true" || "True" || "TRUE" || "1";
	 *   <b>false</b> else
	 * @verdict
	 */
	function str2bool(template charstring p_str) return boolean  {
		if (p_str == "true" or p_str == "True" or p_str == "TRUE" or
			p_str == "1") {
			return true;
		} else {
			return false;
		}
	}
}
