/**
 * @author Sascha Kretzschmann
 * @desc This module provides function for each test case.
 *   		 Additionally this module provide set up and
 *   		 tear down configurations to reuse.
 */
module Car2X_Functions {
	import from Car2X_ModuleParameters {const c_timerHalfSecond;}

	import from Car2X_Templates {
		template
			m_FilterDoorStatusStart,
			m_FilterDoorStatusStop,
			m_FilterEngineSpeedStart,
			m_FilterEngineSpeedStop,
			m_FilterHeadLampStatusStart,
			m_FilterHeadLampStatusStop,
			m_FilterIgnitionStateStart,
			m_FilterIgnitionStateStop,
			m_FilterSteeringWheelStart,
			m_FilterSteeringWheelStop,
			m_FilterTransmissionGearStart,
			m_FilterTransmissionGearStop,
			m_FilterVehicleSpeedStart,
			m_FilterVehicleSpeedStop,
			mw_FilterResponseDoorStatus,
			mw_FilterResponseEngineSpeed,
			mw_FilterResponseHeadLampStatus,
			mw_FilterResponseIgnitionStatus,
			mw_FilterResponseSteeringWheel,
			mw_FilterResponseTransmissionGear,
			mw_FilterResponseVehicleSpeed;
	}

	import from Car2X_Types {
		type DoorStatus, FilterResponse, IgnitionStatus, TransmissionGear;
	}

	import from Car2X_ConfigSystem {type TesterComponentType;}

	/**
	 * @desc Function to measure vehicle speed for a defined period of time.
	 * @param p_speed Target speed (in km/h) as float
	 * @param p_holding_time Time with target speed (in sec)
	 * @param p_variance Variance range around the targetAngle (in km/h)
	 * @param p_interval Time until timeout (in sec)
	 */
	function f_VEHICLE_SPEED(float p_speed, float p_holding_time,
								float p_variance, float p_interval)
		runs on TesterComponentType  {

		t_TC_Global.start;
		filterPort.send(m_FilterVehicleSpeedStart);
		while (t_TC_Global.running) {
			f_VehicleSpeedSub(p_speed, p_holding_time, p_variance,
								   p_interval);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		filterPort.send(m_FilterVehicleSpeedStop);

		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Testbody function for @see f_VEHICLE_SPEED
	 * @verdict pass The given speed is greater than 50.0
	 * @verdict fail Due to invalid parameter
	 * @verdict inconc Due to a timeout
	 */
	function f_VehicleSpeedSub(float p_speed, float p_holding_time,
									float p_variance, float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_speed;
		timer t_holding;
		var float speed;

		// start the timer
		t_TC.start(p_interval);
		alt {
			// store received template into value
//			[]filterPort.receive(mw_Filter_Response_vS:{valueA := decmatch interval(50.0,5.0)}){
//				t_TC.stop;
//			};
			[] filterPort.receive(mw_FilterResponseVehicleSpeed) -> value v_speed {
				t_TC.stop;
				// check whether vehicle speed is greater than given speed
				speed := str2float(v_speed.valueA);
				if (f_max(p_speed - p_variance, 0.0) <= speed and
					speed >= f_min(p_speed + p_variance, 655.0)) {
					t_holding.start(p_holding_time);
					while (t_holding.running and v_ret == pass) {
						filterPort.receive(mw_FilterResponseVehicleSpeed) ->
						value v_speed;
						if (str2float(v_speed.valueA) >= p_speed) {
							v_ret := pass;
						} else {
							v_ret := fail;
						}
					}
				} else {
					v_ret := fail;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Function to measure engine speed for a defined period of time
	 * @param p_engine_speed Target engine speed (in rpm) as integer
	 * @param p_holding_time Time to hold this engine speed (in sec)
	 * @param p_variance Variance for target engine speed (in rpm)
	 * @param p_time_out Time until timeout (in sec)
	 */
	function f_ENGINE_SPEED(float p_engine_speed, float p_holding_time,
							   float p_variance, float p_time_out)
		runs on TesterComponentType  {
		t_TC_Global.start;
		filterPort.send(m_FilterEngineSpeedStart);
		while (t_TC_Global.running) {
			f_EngineSpeedSub(p_engine_speed, p_variance, p_holding_time,
								  1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		filterPort.send(m_FilterEngineSpeedStop);

		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Requests engine speed from CAN filter. Test body for @see f_ENGINE_SPEED
	 * @param p_engine_speed Target engine speed to reach (in rpm)
	 * @param p_variance Variance of target speed
	 * @param p_holding_time Time with target speed (in sec)
	 * @param p_interval Time until timeout (in sec)
	 */
	function f_EngineSpeedSub(float p_engine_speed, float p_variance,
								   float p_holding_time, float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_speed;
		timer t_holding;
		var float speed;

		// start the timer
		t_TC.start(p_interval);
		alt {
			// store received template into value
			[] filterPort.receive(mw_FilterResponseEngineSpeed) -> value v_speed {
				t_TC.stop;
				// check whether vehicle speed is greater than given speed
				speed := str2float(v_speed.valueA);
				if (f_max(p_engine_speed - p_variance, 0.0) <= speed and
					speed >= f_min(p_engine_speed + p_variance, 16382.0)) {
					t_holding.start(p_holding_time);
					while (t_holding.running and v_ret == pass) {
						filterPort.receive(mw_FilterResponseEngineSpeed) ->
						value v_speed;
						if (str2float(v_speed.valueA) >= p_engine_speed) {
							v_ret := pass;
						} else {
							v_ret := fail;
						}
					}
				} else {
					v_ret := fail;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Function to measure steering wheel angle
	 * @param p_targetAngle Angle which should be reached (in degree) as float
	 * @param p_variance Variance of the target angle (in degree) as float
	 * @param p_interval Time until timeout (in sec)
	 */
	function f_STEERING_WHEEL_ANGLE(float p_targetAngle, float p_variance, float p_interval)
		runs on TesterComponentType  {
		t_TC_Global.start;
		// start steering Wheel request
		filterPort.send(m_FilterSteeringWheelStart);

		while (t_TC_Global.running) {
			f_SteeringWheelAngleSub(p_targetAngle, p_variance, p_interval);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}

		// stop steering wheel request
		filterPort.send(m_FilterSteeringWheelStop);

		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Requests steering wheel angle from the CAN filter. Test body of @see f_STEERING_WHEEL_ANGLE
	 * @param p_targetAngle Angle which should be reached
	 * @param p_variance Variance of the target angle
	 * @param p_interval time until timeout; should be greater then the
	 *   intervall time in m_Filter_doorStatus_Start
	 */
	function f_SteeringWheelAngleSub(float p_targetAngle, float p_variance,
										   float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_angle;

		t_TC.start(p_interval);
		alt {
			[] filterPort.receive(mw_FilterResponseSteeringWheel) -> value v_angle {
				if (f_max(p_targetAngle - p_variance, - 600.0) <=
					str2float(v_angle.valueA) and
					str2float(v_angle.valueA) <=
					f_min(p_targetAngle + p_variance, 600.0)) {
					v_ret := pass;
					t_TC.stop;
				} else {
					v_ret := fail;
					t_TC.stop;
				}
			}
			[] filterPort.receive {
				v_ret := fail;
				t_TC.stop;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Function to measure headlamp status.
	 * @param p_Status <b>true</b> headlamp on; <b>false</b> headlamp off
	 * @param p_timeout intervall until timeout (in sec)
	 */
	function f_HEADLAMP_STATUS(boolean p_Status, float p_timeout)
		runs on TesterComponentType  {
		// start ignition status request
		filterPort.send(m_FilterHeadLampStatusStart);
		t_TC_Global.start(p_timeout);

		while (t_TC_Global.running) {
			f_HeadlampStatusSub(p_Status, 0.8);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		// stop ignition status request
		filterPort.send(m_FilterHeadLampStatusStop);

		// stage failed -> end whole TC
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Receives values from CAN filter. Test body of @see f_HEADLAMP_STATUS
	 * @param p_Status Target status of headlamp; <b>true</b> headlamp on;
	 *   <b>false</b> headlamp off
	 * @param p_interval Time until timeout
	 */
	function f_HeadlampStatusSub(boolean p_Status, float p_interval)
		runs on TesterComponentType  {
			
		var template FilterResponse v_headLampStatus;
		t_TC.start(p_interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_FilterResponseHeadLampStatus(p_Status)) {
				t_TC.stop;
				v_ret := pass;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Measures the ignition status.
	 * @param ignitionStatus Enum value of type IgnitionStatus
	 */
	function f_IGNITION_STATUS(IgnitionStatus p_ignitionStatus)
		runs on TesterComponentType  {

		t_TC_Global.start;
		// start ignition status request
		filterPort.send(m_FilterIgnitionStateStart);

		while (t_TC_Global.running) {
			f_IgnitionStatusSub(p_ignitionStatus, c_timerHalfSecond);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		// stop ignition status request
		filterPort.send(m_FilterIgnitionStateStop);

		// stage failed -> end whole TC
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Receive ignition status value from CAN filter and compare with
	 *   target status. Test body for @see f_IGNITION_STATUS.
	 * @param ignitionStatus Enum value of type IgnitionStatus
	 * @param interval Time until timeout. Should be greater then interval in
	 *   m_filterIgnitionStateStart
	 */
	function f_IgnitionStatusSub(IgnitionStatus ignitionStatus,
									  float interval)
		runs on TesterComponentType  {

		var template FilterResponse v_ignitionStatus;
		t_TC.start(interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_FilterResponseIgnitionStatus(e_run)) {
				t_TC.stop;
				v_ret := pass;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Measures transmission gear and compare with target state
	 * @param gear Target state; enum value of type TransmissionGear
	 * @param p_interval time until timeout
	 * @verdict
	 */
	function f_TRANSMISSION_GEAR_STATUS(TransmissionGear gear,
										   float p_interval)
		runs on TesterComponentType  {
		t_TC_Global.start(p_interval);
		filterPort.send(m_FilterTransmissionGearStart);

		while (t_TC_Global.running) {
			f_transmissionGearStatusSub(gear, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		filterPort.send(m_FilterTransmissionGearStop);

		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	/**
	 * @desc Receive transmission gear from CAN filter. Test body for @see f_TRANSMISSION_GEAR_STATUS
	 * @param gear The target gear
	 * @param p_interval Time until timeout. Should be geater then
	 *   m_FilterTransmissionGearStart
	 * @verdict
	 */
	function f_transmissionGearStatusSub(TransmissionGear gear,
											   float p_interval)
		runs on TesterComponentType  {
			
		var template FilterResponse v_gearStatus;
		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_FilterResponseTransmissionGear) -> value v_gearStatus {
				if (f_gearStatus2Str(gear) == v_gearStatus.valueA) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc  Function to get door status from CAN filer.
	 * @param p_door Enumeration value to define which door
	 * @param p_status Status of the door; <b>true</b> for open
	 *   door; <b>false</b> for close door
	 * @param p_interval Defines time until timeout (in sec)
	 * @verdict
	 */
	function f_DOOR_STATUS(DoorStatus p_door, boolean p_status,
							  float p_interval) runs on TesterComponentType  {

		t_TC_Global.start(p_interval);
		filterPort.send(m_FilterDoorStatusStart);

		while (t_TC_Global.running) {
			f_doorStatusSub(p_door, p_status, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		filterPort.send(m_FilterDoorStatusStop);

		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	/**
	 * @desc Function receive door status from canfilter. Test body @see f_DOOR_STATUS
	 * @param p_door Enumeration value to define which door
	 * @param p_status Status of the door; <b>true</b> for open door;
	 *   <b>false</b> for close door
	 * @param p_interval Time until timeout. Should be greater then the
	 *   interval time in m_FilterDoorStatusStart
	 */
	function f_doorStatusSub(DoorStatus p_door, boolean p_status,
								  float p_interval)
		runs on TesterComponentType  {

		var template FilterResponse v_doorStatus;
		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_FilterResponseDoorStatus) -> value v_doorStatus {
				if (f_doorStatus2Str(p_door) == v_doorStatus.valueA and
					p_status == v_doorStatus.valueB) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	/**
	 * @desc Set up the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 Maps the port of the tester to the system port.
	 */
	function f_setUp() runs on TesterComponentType  {


		// create an instance of the tester
		var TesterComponentType Tester;
		Tester := TesterComponentType.create;

		v_ret := pass;
		v_stage := 1;

		// map the tester port to the system port
		map(self:filterPort, system:filterPort);
	}

	/**
	 * @desc Auxiliary function to find max value of two float values
	 * @param valueA
	 * @param valueB
	 * @return The maximum value.
	 */
	function f_max(float p_valueA, float p_valueB) return float  {
		if (p_valueA > p_valueB) {
			return p_valueA;
		} else {
			return p_valueB;
		}
	}

	/**
	 * @desc Auxiliary function to find min value of two float values
	 * @param valueA
	 * @param valueB
	 * @return The minimum value
	 */
	function f_min(float p_valueA, float p_valueB) return float  {
		if (p_valueA < p_valueB) {
			return p_valueA;
		} else {
			return p_valueB;
		}
	}

	/**
	 * @desc Auxiliary function to cast the ignitionStatus to charstring.
	 *   		 We cannot compare an enum type with a charstring that is
	 *   		 needed for the function @see f_ignitionStatus_SUB
	 * @param ignitionStatus Ignition status to cast.
	 * @return charstring Ignition status as charstring
	 */
	function f_ignitionStatus2str(IgnitionStatus p_ignitionStatus)
		return charstring  {
		select (p_ignitionStatus) {
			case (e_off) {
				return "off";
			}
			case (e_accessory) {
				return "accessory";
			}
			case (e_run) {
				return "run";
			}
			case (e_start) {
				return "start";
			}
		}
	}

	/**
	 * @desc Auxiliary function to cast enum value of DoorStatus to charstring
	 * @param doorStatus The door status to cast
	 * @return The door status as charstring
	 */
	function f_doorStatus2Str(DoorStatus p_doorStatus) return charstring  {
		select (p_doorStatus) {
			case (e_driver) {
				return "driver";
			}
			case (e_passenger) {
				return "passener";
			}
			case (e_rearLeft) {
				return "rear_left";
			}
			case (e_rearRight) {
				return "rear_right";
			}
		}
	}

	/**
	 * @desc Auxiliary function to cast enum value of TransmissionGear to charstring
	 * @param gear The gear status to cast
	 * @return The gear status as charstring
	 */
	function f_gearStatus2Str(TransmissionGear p_gear) return charstring  {
		select (p_gear) {
			case (e_first) {
				return "first";
			}
			case (e_second) {
				return "second";
			}
			case (e_third) {
				return "third";
			}
			case (e_fourth) {
				return "fourth";
			}
			case (e_fifth) {
				return "fifth";
			}
			case (e_sixth) {
				return "sixth";
			}
			case (e_seventh) {
				return "seventh";
			}
			case (e_eighth) {
				return "eighth";
			}
			case (e_nineth) {
				return "nineth";
			}
			case (e_tenth) {
				return "tenth";
			}
			case (e_reverse) {
				return "reverse";
			}
			case (e_neutral) {
				return "neutral";
			}
		}
	}

	/**
	 * @desc Tear down the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 UnMaps the ports.
	 */
	function f_tearDown() runs on TesterComponentType  {
		unmap(self:filterPort, system:filterPort);
		stop;
	}
	
	/**
	 * @desc Function to set the verdict and communicate via the action statment
	 *   with TTman.
	 *   		 Furthermore, increment the stage for the test case.
	 * @param verdict Verdicttype for the given stage.
	 * @param stage Stage Current stage.
	 * @return integer The new stage.
	 * TODO: new stage as return
	 */
	function f_setVerdictAndStage(verdicttype p_verdict, integer p_stage, float p_globalTimer) runs on TesterComponentType{
		setverdict(p_verdict);
		p_stage := p_stage + 1;
		// send stage information
		action("stage:" & int2str(p_stage) & ",timeWindow:" & int2str(float2int(p_globalTimer)));
	}

	/**
	 * @desc Auxiliary function to cast a received charstring to boolean
	 * @param p_str
	 * @return <b>true</b> if p_str == "true" || "True" || "TRUE" || "1";
	 *   <b>false</b> else
	 * @verdict
	 */
	function f_str2bool(template charstring p_str) return boolean  {
		if (p_str == "true" or p_str == "True" or p_str == "TRUE" or
			p_str == "1") {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * 
	 * @desc Auxiliary function to cast a given boolean to a charstring
	 * @param status The boolean you want to cast
	 * @return The casted charstring
	 */
	function f_bool2str(boolean p_status) return charstring  {
		if (p_status) {
			return "true";
		} else {
			return "false";
		}
	}
}
