/**
 * @author Sascha Kretzschmann
 * @desc This module provides function for each test case.
 *   		 Additionally this module provide set up and
 *   		 tear down configurations to reuse.
 */
module Car2X_Functions {
	import from Car2X_Templates {
		template
			m_Filter_doorStatus_Start,
			m_Filter_doorStatus_Stop,
			m_Filter_headLampStatus_Start,
			m_Filter_headLampStatus_Stop,
			m_Filter_ignitionState_Start,
			m_Filter_ignitionState_Stop,
			m_Filter_steeringWheel_Start,
			m_Filter_steeringWheel_Stop,
			m_Filter_transmissionGear_Start,
			m_Filter_transmissionGear_Stop,
			mw_Filter_Response_dS,
			mw_Filter_Response_hL,
			mw_Filter_Response_iS,
			mw_Filter_Response_sW,
			mw_Filter_Response_tG,
			mw_Filter_Response_vS;
	}

	import from Car2X_Types {
		type DoorStatus, FilterResponse, IgnitionStatus, TransmissionGear;
	}

	import from Car2X_ConfigSystem {type TesterComponentType;}

	function f_TP_VEHICLE_SPEED(float p_speed, float p_holding_time,
								float p_interval) runs on TesterComponentType  {
		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_VEHICLE_SPEED_SUB(p_speed, p_holding_time, p_interval);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	/**
	 * @desc Testbody function for
	 * @see Car2X_Testcases.TC_VEHICLE_SPEED_OVER_50
	 * @verdict pass The given speed ist greater than 50.0.
	 * @verdict fail Due to invalid parameter.
	 * @verdict inconc Due to a timeout.
	 */
	function f_TP_VEHICLE_SPEED_SUB(float p_speed, float p_holding_time,
									float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_speed;
		timer t_holding;
		var float speed;

		// start the timer
		t_TC.start(p_interval);
		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_vS) -> value v_speed {
				t_TC.stop;
				// check whether vehicle speed is greater than given speed
				if (str2float(v_speed.valueA) >= p_speed) {
					t_holding.start(p_holding_time);
					while (t_holding.running and v_ret == pass) {
						filterPort.receive(mw_Filter_Response_vS) ->
						value v_speed;
						if (str2float(v_speed.valueA) >= p_speed) {
							v_ret := pass;
						} else {
							v_ret := fail;
						}
					}
				} else {
					v_ret := fail;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
	}

	function f_TP_STEERING_WHEEL_ANGLE(float targetAngle, float variance)
		runs on TesterComponentType  {
		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_STEERING_WHEEL_ANGLE_SUB(- 600.0, 50.0, 2.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			f_tearDown();
		}
	}

	function f_TP_STEERING_WHEEL_ANGLE_SUB(float targetAngle, float variance,
										   float interval)
		runs on TesterComponentType  {
		var template FilterResponse v_angle;

		// start steering Wheel request
		filterPort.send(m_Filter_steeringWheel_Start);

		t_TC.start(interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_sW) -> value v_angle {
				if (max(targetAngle - variance, - 600.0) <=
					str2float(v_angle.valueA) and
					str2float(v_angle.valueA) <=
					min(targetAngle + variance, 600.0)) {
					v_ret := pass;
					t_TC.stop;
				} else {
					v_ret := fail;
					t_TC.stop;
				}
			}
			[] filterPort.receive {
				v_ret := fail;
				t_TC.stop;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		// stop steering wheel request
		filterPort.send(m_Filter_steeringWheel_Stop);
	}

	function f_TP_HEADLAMP_STATUS(boolean p_Status)
		runs on TesterComponentType  {

		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_HEADLAMP_STATUS_SUB(p_Status, 0.5);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
	}

	function f_TP_HEADLAMP_STATUS_SUB(boolean p_Status, float p_interval)
		runs on TesterComponentType  {
		var template FilterResponse v_headLampStatus;

		// start ignition status request
		filterPort.send(m_Filter_headLampStatus_Start);

		t_TC.start(p_interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_hL) ->
			   value v_headLampStatus {
				if (p_Status == str2bool(v_headLampStatus.valueA)) {
					v_ret := pass;
				} else {
					v_ret := fail;
				}
				t_TC.stop;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		// stop ignition status request
		filterPort.send(m_Filter_headLampStatus_Stop);
	}

	function f_TP_IGNITION_STATUS(IgnitionStatus ignitionStatus)
		runs on TesterComponentType  {

		t_TC_Global.start;
		while (t_TC_Global.running) {
			f_TP_IGNITION_STATUS_SUB(ignitionStatus, 0.5);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
	}

	function f_TP_IGNITION_STATUS_SUB(IgnitionStatus ignitionStatus,
									  float interval)
		runs on TesterComponentType  {

		var template FilterResponse v_ignitionStatus;

		// start ignition status request
		filterPort.send(m_Filter_ignitionState_Start);

		t_TC.start(interval);

		alt {
			// store received template into value
			[] filterPort.receive(mw_Filter_Response_iS) ->
			   value v_ignitionStatus {
				if (ignitionStatus2str(ignitionStatus) ==
					v_ignitionStatus.valueA) {
					v_ret := pass;
				} else {
					v_ret := fail;
				}
				t_TC.stop;
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		// stop ignition status request
		filterPort.send(m_Filter_ignitionState_Stop);
	}

	function f_TP_TRANSMISSION_GEAR_STATUS(TransmissionGear gear,
										   float p_interval)
		runs on TesterComponentType  {
		t_TC_Global.start(p_interval);

		while (t_TC_Global.running) {
			f_TP_TRANSMISSION_GEAR_STATUS_SUB(gear, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	function f_TP_TRANSMISSION_GEAR_STATUS_SUB(TransmissionGear gear,
											   float p_interval) runs on TesterComponentType{
		var template FilterResponse v_gearStatus;

		filterPort.send(m_Filter_transmissionGear_Start);
		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_tG) -> value v_gearStatus {
				if (gearStatus2Str(v_gearStatus) == v_gearStatus.valueA) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}
		filterPort.send(m_Filter_transmissionGear_Stop);
	}

	function f_TP_DOOR_STATUS(DoorStatus p_door, boolean p_status,
							  float p_interval) runs on TesterComponentType  {

		t_TC_Global.start(p_interval);

		while (t_TC_Global.running) {
			f_TP_DOOR_STATUS_SUB(p_door, p_status, 1.0);
			if (v_ret == pass) {
				t_TC_Global.stop;
			}
		}
		if (v_ret != pass) {
			setverdict(v_ret);
			// send verdict
			f_tearDown();
		}
	}

	function f_TP_DOOR_STATUS_SUB(DoorStatus p_door, boolean p_status,
								  float p_interval)
		runs on TesterComponentType  {

		var template FilterResponse v_doorStatus;

		filterPort.send(m_Filter_doorStatus_Start);

		t_TC.start(p_interval);

		alt {
			[] filterPort.receive(mw_Filter_Response_dS) -> value v_doorStatus {
				if (doorStatus2Str(p_door) == v_doorStatus.valueA and
					p_status == v_doorStatus.valueB) {
					v_ret := pass;
				}
			}
			[] filterPort.receive {
				t_TC.stop;
				v_ret := fail;
			}
			[] t_TC.timeout {
				v_ret := inconc;
			}
		}

		filterPort.send(m_Filter_doorStatus_Stop);
	}

	/**
	 * @desc Set up the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 Maps the port of the tester to the system port.
	 */
	function f_setUp() runs on TesterComponentType  {




		// create an instance of the tester
		var TesterComponentType Tester;
		Tester := TesterComponentType.create;

		v_ret := pass;
		v_stage := 1;

		// map the tester port to the system port
		map(self:filterPort, system:filterPort);
	}

	function max(float valueA, float valueB) return float  {
		if (valueA > valueB) {
			return valueA;
		} else {
			return valueB;
		}
	}

	function min(float valueA, float valueB) return float  {
		if (valueA < valueB) {
			return valueA;
		} else {
			return valueB;
		}
	}

	/**
	 * @desc Auxiliary function to cast the ignitionStatus to charstring.
	 *   		 We cannot compare an enum type with a charstring that is
	 *   		 needed for the function
	 * @see f_ignitionStatus_SUB
	 * @param ignitionStatus
	 * @return charstring Ignition status as string
	 */
	function ignitionStatus2str(IgnitionStatus ignitionStatus)
		return charstring  {
		select (ignitionStatus) {
			case (e_off) {
				return "off";
			}
			case (e_accessory) {
				return "accessory";
			}
			case (e_run) {
				return "run";
			}
			case (e_start) {
				return "start";
			}
		}
	}

	function doorStatus2Str(DoorStatus doorStatus) return charstring  {
		select (doorStatus) {
			case (e_driver) {
				return "driver";
			}
			case (e_passenger) {
				return "passener";
			}
			case (e_rear_left) {
				return "rear_left";
			}
			case (e_rear_right) {
				return "rear_right";
			}
		}
	}
	
	function gearStatus2Str(TransmissionGear gear) return charstring  {
			select (gear) {
			case (e_first) {
				return "first";
			}
			case (e_second) {
				return "second";
			}
			case (e_third) {
				return "third";
			}
			case (e_fourth) {
				return "fourth";
			}
			case (e_fifth) {
				return "fifth";
			}
			case (e_sixth) {
				return "sixth";
			}
			case (e_seventh) {
				return "seventh";
			}
			case (e_eighth) {
				return "first";
			}
			case (e_ninth) {
				return "ninth";
			}
			case (e_tenth) {
				return "tenth";
			}
			case (e_reverse) {
				return "reverse";
			}
			case (e_neutral) {
				return "neutral";
			}
			}
		}

	/**
	 * @desc Function to set the verdict and communicate via the action statment
	 *   with TTman.
	 *   		 Furthermore, increment the stage for the test case.
	 * @param verdict Verdicttype for the given stage.
	 * @param stage Stage Current stage.
	 * @return integer The new stage.
	 */
	function f_set_verdict_and_stage(verdicttype verdict, integer stage) {
		setverdict(verdict);
		stage := stage + 1;
		// send stage information
		action("stage:" & int2str(stage));
	}

	/**
	 * @desc Tear down the configuration for test cases running on
	 * @see Car2X_ConfigSystem.TesterComponentType.
	 *   		 UnMaps the ports.
	 */
	function f_tearDown() runs on TesterComponentType  {
		unmap(self:filterPort, system:filterPort);
		stop;
	}

	function str2bool(template charstring p_str) return boolean  {
		if (p_str == "true" or p_str == "True" or p_str == "TRUE" or
			p_str == "1") {
			return true;
		} else {
			return false;
		}
	}
}
